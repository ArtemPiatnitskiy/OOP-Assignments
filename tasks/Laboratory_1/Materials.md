# Полезная информация

#### Что это?

Тут я собрал информацию, которая была для меня полезной, во время решения данной лабораторной работы. 

В процессе решения возникают вопросы, в которых необходимо разобраться. Информаицю я нахожу в интернете, или спрашиваю у нейросетей. 

В случае, если у меня возникает какой-то вопрос, найденную информацию я сохраняю сюда.

---------------------

Что такое **CRT (C Runtime Library)** и почему важно настраивать его использование в проектах на C++.

### Что такое CRT (C Runtime Library)?

**C Runtime Library (CRT)** — это набор стандартных библиотек, которые предоставляют базовую функциональность для программ на C и C++. Это включает в себя такие функции, как выделение памяти, обработка ошибок, ввод/вывод, работу со строками и другие утилиты. В Windows CRT реализован через несколько различных библиотек.

Важный момент: на Windows существует два основных типа CRT, которые могут быть использованы:

1. **Статическая CRT** (`/MT` или `/MTd`):
   
   - Библиотека CRT компилируется прямо в исполнимый файл, то есть весь код библиотеки включается в твой проект.
   
   - При использовании статической CRT каждый проект, который компилируется с этим вариантом, будет иметь свою версию библиотеки.

2. **Динамическая CRT** (`/MD` или `/MDd`):
   
   - Библиотека CRT используется как **динамическая** (DLL). Вместо того чтобы компилировать её в исполнимый файл, твой проект будет ссылаться на внешний файл библиотеки, например, `msvcrt.dll`.
   
   - В этом случае несколько проектов могут использовать одну и ту же версию CRT, которая будет загружена в память при запуске программы.

### Почему важна настройка CRT в проектах?

Когда проект компилируется с использованием одной из этих версий CRT, важно, чтобы все части проекта использовали **одинаковую версию**. Если один проект использует **статическую CRT**, а другой — **динамическую CRT**, это может привести к серьёзным проблемам с совместимостью, особенно при использовании совместных данных, таких как объекты с динамически выделенной памятью.

#### Проблемы, которые могут возникнуть из-за несовпадения CRT:

1. **Дублирование кода**:  
   Если один проект компилируется с **динамической CRT**, а другой с **статической**, то в процессе работы программы может возникнуть ситуация, когда каждый проект будет иметь свою собственную версию CRT. Это может привести к множественному определению одних и тех же функций или даже к ошибкам выполнения.

2. **Проблемы с выделением и освобождением памяти**:  
   Статическая CRT и динамическая CRT имеют свои внутренние механизмы работы с памятью. Например, если один проект выделяет память через динамическую CRT, а другой — через статическую, то освобождение этой памяти может вызвать ошибки, такие как двойное освобождение или утечки памяти, так как каждый проект будет использовать свою "память" для управления динамическими объектами.

3. **Несоответствие параметров компиляции**:  
   Если один проект компилируется с флагом `/MT` (статическая CRT), а другой — с `/MD` (динамическая CRT), то параметры компиляции могут не совпадать, что приведёт к проблемам с линковкой и неопределённому поведению.

### Зачем использовать `gtest_force_shared_crt ON`?

Теперь, когда мы понимаем, что такое CRT и какие проблемы могут возникнуть из-за использования разных вариантов, давай разберём, зачем устанавливается эта строка в CMake:

```cmake
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
```

Эта строка указывает, что **Google Test (gtest)** должен быть собран с использованием **динамической версии CRT**, даже если проект по умолчанию использует статическую версию.

- **`gtest_force_shared_crt ON`** — это установка флага для библиотеки Google Test, который заставляет её использовать **общую (динамическую) CRT**.

- **`CACHE BOOL "" FORCE`** — это принудительно изменяет значение этого флага, если оно было задано где-то в CMake, гарантируя, что Google Test будет собран с динамической CRT, независимо от того, как настроены другие части проекта.

### Когда это особенно важно?

- **Совместимость с другими библиотеками**: Если твой проект использует другие библиотеки, которые также используют динамическую CRT, то важно, чтобы и Google Test был собран с динамической CRT, чтобы избежать проблем с совместной работой библиотек.

- **Сторонние зависимости**: Если проект зависит от сторонних библиотек (например, библиотека на C++, которая также использует динамическую CRT), и ты используешь Google Test, то важно, чтобы он был собран с той же CRT, чтобы избежать конфликтов.

- **Windows**: Это особенно важно на Windows, потому что там CRT играет более явную роль в работе с памятью и вызовами системных функций.

### Пример сценария:

Допустим, у тебя есть проект, который использует несколько библиотек:

- **Основной проект** компилируется с **динамической CRT** (`/MD`).

- **Google Test** (который ты добавляешь через CMake) по умолчанию собирается с **статической CRT** (`/MT`).

В результате при сборке проекта могут возникнуть проблемы, если ты попытаешься использовать Google Test для тестирования: из-за того, что проект и Google Test используют разные версии CRT, они не смогут корректно обмениваться данными, выделять или освобождать память.

Чтобы избежать этого, ты заставляешь CMake принудительно собирать Google Test с **динамической CRT**, что делает проект совместимым с другими библиотеками, использующими динамическую CRT.

---

### Важно понимать:

- **Статическая CRT**: Хорошо подходит для небольших приложений, где не предполагается использования других библиотек или сложных взаимодействий.

- **Динамическая CRT**: Лучше подходит для больших проектов или для проектов, которые используют сторонние библиотеки, так как она позволяет совместно использовать один экземпляр библиотеки CRT между разными частями программы.

Таким образом, использование `gtest_force_shared_crt ON` помогает избежать проблем с совместимостью в случае, если проект и Google Test должны работать с одной и той же версией CRT.

---

# Что такое cmake и почему он нужен

## Что такое CMake?

**CMake** — это система автоматизации сборки, которая помогает управлять процессом компиляции программ. Она генерирует конфигурационные файлы для компиляторов (например, Makefile или проектные файлы для IDE), позволяя собирать проект на разных операционных системах и с использованием различных компиляторов.

Вместо того чтобы вручную писать Makefile или конфигурировать IDE, с помощью CMake можно указать, как собирать проект, и CMake сам позаботится об этом.

### Зачем нужен CMake?

1. **Кросс-платформенность**: CMake позволяет собирать проект на разных операционных системах (Linux, macOS, Windows) и с разными компиляторами.

2. **Управление зависимостями**: CMake помогает легко подключать сторонние библиотеки (например, Boost, OpenCV).

3. **Интеграция с IDE**: CMake может генерировать файлы конфигурации для популярных IDE (например, Visual Studio, CLion, Xcode).

4. **Удобство тестирования**: CMake поддерживает интеграцию с тестами, например, с Google Test.

---

## Основные команды CMake (для простых проектов)

### 1. **`project(<имя проекта>)`**

```cmake
project(MyProject)
```

Эта команда устанавливает название проекта и задаёт языки программирования, которые будут использоваться (по умолчанию C и C++).

- **Зачем это нужно**: Устанавливает контекст проекта. Имя проекта используется в других командах (например, для названия исполнимых файлов или библиотек).

---

### 2. **`add_executable(<имя_файла> <список_файлов>)`**

```cmake
add_executable(MyProjectExe main.cpp)
```

Создаёт исполнимый файл, который будет скомпилирован из указанных исходных файлов.

- **Зачем это нужно**: Указывает, какой файл будет являться точкой входа в программу (обычно это файл с функцией `main()`).

---

### 3. **`add_library(<имя_библиотеки> <список_файлов>)`**

```cmake
add_library(MyLibrary src/calculator.cpp)
```

Создаёт библиотеку (статическую или динамическую), которая будет скомпилирована из указанных исходных файлов.

- **Зачем это нужно**: Если в проекте есть повторяющиеся компоненты или функции, которые могут быть использованы в разных частях проекта, то их можно вынести в отдельную библиотеку. Это улучшает читаемость и поддерживаемость кода.

---

### 4. **`target_link_libraries(<цель> <библиотеки>)`**

```cmake
target_link_libraries(MyProjectExe PRIVATE MyLibrary)
```

Связывает исполнимый файл или библиотеку с другими библиотеками.

- **Зачем это нужно**: Если исполнимый файл или библиотека зависит от другой библиотеки, нужно указать эту зависимость. Это гарантирует, что библиотеки будут правильно связаны в процессе сборки.

---

## Более сложные команды CMake

### 5. **`set(<переменная> <значение>)`**

```cmake
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

Эта команда устанавливает значение переменной для использования в процессе сборки. В данном случае, она указывает компилятору использовать стандарт C++20.

- **Зачем это нужно**: Позволяет настроить параметры сборки, такие как стандарт C++ или другие флаги компилятора. Это может быть полезно для обеспечения совместимости с определёнными версиями стандартов или библиотек.

---

### 6. **`include(<путь к файлу>)`**

```cmake
include(FetchContent)
```

Позволяет включить внешний CMake файл или модуль в текущую конфигурацию.

- **Зачем это нужно**: Например, можно подключить готовые модули или сторонние библиотеки, например, для работы с Google Test или автоматической загрузки зависимостей. Это позволяет не повторно писать код, а использовать уже готовые решения.

---

### 7. **`enable_testing()` и `add_test()`**

```cmake
enable_testing()
add_test(NAME MyTest COMMAND my_test_exe)
```

- `enable_testing()` — включает поддержку тестов в CMake.

- `add_test()` — добавляет новый тест в проект.

- **Зачем это нужно**: Эти команды необходимы, если ты хочешь интегрировать тестирование в процесс сборки. С помощью CMake можно запускать юнит-тесты (например, с Google Test).

---

### 8. **`FetchContent`**

```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG v1.15.0
)
FetchContent_MakeAvailable(googletest)
```

Позволяет загружать и включать сторонние библиотеки непосредственно из репозиториев (например, с GitHub).

- **Зачем это нужно**: Это полезно, когда нужно подключить внешнюю библиотеку, но нет желания вручную её скачивать или настраивать. С помощью `FetchContent` можно загрузить библиотеку прямо из исходного репозитория и добавить её в проект.

---

### 9. **`find_package`**

```cmake
find_package(OpenCV REQUIRED)
```

Ищет установленную библиотеку на системе и настраивает её для использования в проекте.

- **Зачем это нужно**: Если ты используешь сторонние библиотеки (например, OpenCV или Boost), `find_package` позволяет найти их в системе и подключить для использования в проекте.

---

## Пример: Структура простого проекта с CMake

Допустим, у нас есть проект, который включает в себя библиотеку и исполнимый файл. Структура проекта такая:

```
MyProject/
├── CMakeLists.txt
├── src/
│   ├── calculator.cpp
│   └── calculator.h
└── main.cpp
```

В **CMakeLists.txt**:

```cmake
cmake_minimum_required(VERSION 3.10)

# Устанавливаем имя проекта
project(MyProject)

# Указываем стандарт C++
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Создаём библиотеку
add_library(MyLibrary src/calculator.cpp)

# Создаём исполнимый файл
add_executable(MyProjectExe main.cpp)

# Линкуем библиотеку с исполнимым файлом
target_link_libraries(MyProjectExe PRIVATE MyLibrary)
```

Здесь:

1. Мы создаём библиотеку `MyLibrary` из исходников `src/calculator.cpp`.

2. Мы создаём исполнимый файл `MyProjectExe` из `main.cpp`.

3. Мы связываем исполнимый файл с библиотекой `MyLibrary` через `target_link_libraries`.

---

## Почему CMake полезен?

CMake помогает организовать процесс сборки, позволяя:

- Легко переходить между различными платформами и компиляторами.

- Работать с большими проектами, где код разделён на несколько библиотек.

- Автоматически загружать и настраивать зависимости.

- Упрощать работу с IDE и тестами.

CMake служит связующим звеном, которое помогает управлять сборкой проекта, организуя всё в удобный и гибкий процесс.
