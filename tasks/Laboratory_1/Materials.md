# Полезная информация

#### Что это?

Тут я собрал информацию, которая была для меня полезной, во время решения данной лабораторной работы. 

В процессе решения возникают вопросы, в которых необходимо разобраться. Информаицю я нахожу в интернете, или спрашиваю у нейросетей. 

В случае, если у меня возникает какой-то вопрос, найденную информацию я сохраняю сюда.

---------------------

Что такое **CRT (C Runtime Library)** и почему важно настраивать его использование в проектах на C++.

### Что такое CRT (C Runtime Library)?

**C Runtime Library (CRT)** — это набор стандартных библиотек, которые предоставляют базовую функциональность для программ на C и C++. Это включает в себя такие функции, как выделение памяти, обработка ошибок, ввод/вывод, работу со строками и другие утилиты. В Windows CRT реализован через несколько различных библиотек.

Важный момент: на Windows существует два основных типа CRT, которые могут быть использованы:

1. **Статическая CRT** (`/MT` или `/MTd`):
   
   - Библиотека CRT компилируется прямо в исполнимый файл, то есть весь код библиотеки включается в твой проект.
   
   - При использовании статической CRT каждый проект, который компилируется с этим вариантом, будет иметь свою версию библиотеки.

2. **Динамическая CRT** (`/MD` или `/MDd`):
   
   - Библиотека CRT используется как **динамическая** (DLL). Вместо того чтобы компилировать её в исполнимый файл, твой проект будет ссылаться на внешний файл библиотеки, например, `msvcrt.dll`.
   
   - В этом случае несколько проектов могут использовать одну и ту же версию CRT, которая будет загружена в память при запуске программы.

### Почему важна настройка CRT в проектах?

Когда проект компилируется с использованием одной из этих версий CRT, важно, чтобы все части проекта использовали **одинаковую версию**. Если один проект использует **статическую CRT**, а другой — **динамическую CRT**, это может привести к серьёзным проблемам с совместимостью, особенно при использовании совместных данных, таких как объекты с динамически выделенной памятью.

#### Проблемы, которые могут возникнуть из-за несовпадения CRT:

1. **Дублирование кода**:  
   Если один проект компилируется с **динамической CRT**, а другой с **статической**, то в процессе работы программы может возникнуть ситуация, когда каждый проект будет иметь свою собственную версию CRT. Это может привести к множественному определению одних и тех же функций или даже к ошибкам выполнения.

2. **Проблемы с выделением и освобождением памяти**:  
   Статическая CRT и динамическая CRT имеют свои внутренние механизмы работы с памятью. Например, если один проект выделяет память через динамическую CRT, а другой — через статическую, то освобождение этой памяти может вызвать ошибки, такие как двойное освобождение или утечки памяти, так как каждый проект будет использовать свою "память" для управления динамическими объектами.

3. **Несоответствие параметров компиляции**:  
   Если один проект компилируется с флагом `/MT` (статическая CRT), а другой — с `/MD` (динамическая CRT), то параметры компиляции могут не совпадать, что приведёт к проблемам с линковкой и неопределённому поведению.

### Зачем использовать `gtest_force_shared_crt ON`?

Теперь, когда мы понимаем, что такое CRT и какие проблемы могут возникнуть из-за использования разных вариантов, давай разберём, зачем устанавливается эта строка в CMake:

```cmake
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
```

Эта строка указывает, что **Google Test (gtest)** должен быть собран с использованием **динамической версии CRT**, даже если проект по умолчанию использует статическую версию.

- **`gtest_force_shared_crt ON`** — это установка флага для библиотеки Google Test, который заставляет её использовать **общую (динамическую) CRT**.

- **`CACHE BOOL "" FORCE`** — это принудительно изменяет значение этого флага, если оно было задано где-то в CMake, гарантируя, что Google Test будет собран с динамической CRT, независимо от того, как настроены другие части проекта.

### Когда это особенно важно?

- **Совместимость с другими библиотеками**: Если твой проект использует другие библиотеки, которые также используют динамическую CRT, то важно, чтобы и Google Test был собран с динамической CRT, чтобы избежать проблем с совместной работой библиотек.

- **Сторонние зависимости**: Если проект зависит от сторонних библиотек (например, библиотека на C++, которая также использует динамическую CRT), и ты используешь Google Test, то важно, чтобы он был собран с той же CRT, чтобы избежать конфликтов.

- **Windows**: Это особенно важно на Windows, потому что там CRT играет более явную роль в работе с памятью и вызовами системных функций.

### Пример сценария:

Допустим, у тебя есть проект, который использует несколько библиотек:

- **Основной проект** компилируется с **динамической CRT** (`/MD`).

- **Google Test** (который ты добавляешь через CMake) по умолчанию собирается с **статической CRT** (`/MT`).

В результате при сборке проекта могут возникнуть проблемы, если ты попытаешься использовать Google Test для тестирования: из-за того, что проект и Google Test используют разные версии CRT, они не смогут корректно обмениваться данными, выделять или освобождать память.

Чтобы избежать этого, ты заставляешь CMake принудительно собирать Google Test с **динамической CRT**, что делает проект совместимым с другими библиотеками, использующими динамическую CRT.

---

### Важно понимать:

- **Статическая CRT**: Хорошо подходит для небольших приложений, где не предполагается использования других библиотек или сложных взаимодействий.

- **Динамическая CRT**: Лучше подходит для больших проектов или для проектов, которые используют сторонние библиотеки, так как она позволяет совместно использовать один экземпляр библиотеки CRT между разными частями программы.

Таким образом, использование `gtest_force_shared_crt ON` помогает избежать проблем с совместимостью в случае, если проект и Google Test должны работать с одной и той же версией CRT.

---

# Что такое cmake и почему он нужен

## Что такое CMake?

**CMake** — это система автоматизации сборки, которая помогает управлять процессом компиляции программ. Она генерирует конфигурационные файлы для компиляторов (например, Makefile или проектные файлы для IDE), позволяя собирать проект на разных операционных системах и с использованием различных компиляторов.

Вместо того чтобы вручную писать Makefile или конфигурировать IDE, с помощью CMake можно указать, как собирать проект, и CMake сам позаботится об этом.

### Зачем нужен CMake?

1. **Кросс-платформенность**: CMake позволяет собирать проект на разных операционных системах (Linux, macOS, Windows) и с разными компиляторами.

2. **Управление зависимостями**: CMake помогает легко подключать сторонние библиотеки (например, Boost, OpenCV).

3. **Интеграция с IDE**: CMake может генерировать файлы конфигурации для популярных IDE (например, Visual Studio, CLion, Xcode).

4. **Удобство тестирования**: CMake поддерживает интеграцию с тестами, например, с Google Test.

---

## Основные команды CMake (для простых проектов)

### 1. **`project(<имя проекта>)`**

```cmake
project(MyProject)
```

Эта команда устанавливает название проекта и задаёт языки программирования, которые будут использоваться (по умолчанию C и C++).

- **Зачем это нужно**: Устанавливает контекст проекта. Имя проекта используется в других командах (например, для названия исполнимых файлов или библиотек).

---

### 2. **`add_executable(<имя_файла> <список_файлов>)`**

```cmake
add_executable(MyProjectExe main.cpp)
```

Создаёт исполнимый файл, который будет скомпилирован из указанных исходных файлов.

- **Зачем это нужно**: Указывает, какой файл будет являться точкой входа в программу (обычно это файл с функцией `main()`).

---

### 3. **`add_library(<имя_библиотеки> <список_файлов>)`**

```cmake
add_library(MyLibrary src/calculator.cpp)
```

Создаёт библиотеку (статическую или динамическую), которая будет скомпилирована из указанных исходных файлов.

- **Зачем это нужно**: Если в проекте есть повторяющиеся компоненты или функции, которые могут быть использованы в разных частях проекта, то их можно вынести в отдельную библиотеку. Это улучшает читаемость и поддерживаемость кода.

---

### 4. **`target_link_libraries(<цель> <библиотеки>)`**

```cmake
target_link_libraries(MyProjectExe PRIVATE MyLibrary)
```

Связывает исполнимый файл или библиотеку с другими библиотеками.

- **Зачем это нужно**: Если исполнимый файл или библиотека зависит от другой библиотеки, нужно указать эту зависимость. Это гарантирует, что библиотеки будут правильно связаны в процессе сборки.

---

## Более сложные команды CMake

### 5. **`set(<переменная> <значение>)`**

```cmake
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

Эта команда устанавливает значение переменной для использования в процессе сборки. В данном случае, она указывает компилятору использовать стандарт C++20.

- **Зачем это нужно**: Позволяет настроить параметры сборки, такие как стандарт C++ или другие флаги компилятора. Это может быть полезно для обеспечения совместимости с определёнными версиями стандартов или библиотек.

---

### 6. **`include(<путь к файлу>)`**

```cmake
include(FetchContent)
```

Позволяет включить внешний CMake файл или модуль в текущую конфигурацию.

- **Зачем это нужно**: Например, можно подключить готовые модули или сторонние библиотеки, например, для работы с Google Test или автоматической загрузки зависимостей. Это позволяет не повторно писать код, а использовать уже готовые решения.

---

### 7. **`enable_testing()` и `add_test()`**

```cmake
enable_testing()
add_test(NAME MyTest COMMAND my_test_exe)
```

- `enable_testing()` — включает поддержку тестов в CMake.

- `add_test()` — добавляет новый тест в проект.

- **Зачем это нужно**: Эти команды необходимы, если ты хочешь интегрировать тестирование в процесс сборки. С помощью CMake можно запускать юнит-тесты (например, с Google Test).

---

### 8. **`FetchContent`**

```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG v1.15.0
)
FetchContent_MakeAvailable(googletest)
```

Позволяет загружать и включать сторонние библиотеки непосредственно из репозиториев (например, с GitHub).

- **Зачем это нужно**: Это полезно, когда нужно подключить внешнюю библиотеку, но нет желания вручную её скачивать или настраивать. С помощью `FetchContent` можно загрузить библиотеку прямо из исходного репозитория и добавить её в проект.

---

### 9. **`find_package`**

```cmake
find_package(OpenCV REQUIRED)
```

Ищет установленную библиотеку на системе и настраивает её для использования в проекте.

- **Зачем это нужно**: Если ты используешь сторонние библиотеки (например, OpenCV или Boost), `find_package` позволяет найти их в системе и подключить для использования в проекте.

---

## Пример: Структура простого проекта с CMake

Допустим, у нас есть проект, который включает в себя библиотеку и исполнимый файл. Структура проекта такая:

```
MyProject/
├── CMakeLists.txt
├── src/
│   ├── calculator.cpp
│   └── calculator.h
└── main.cpp
```

В **CMakeLists.txt**:

```cmake
cmake_minimum_required(VERSION 3.10)

# Устанавливаем имя проекта
project(MyProject)

# Указываем стандарт C++
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Создаём библиотеку
add_library(MyLibrary src/calculator.cpp)

# Создаём исполнимый файл
add_executable(MyProjectExe main.cpp)

# Линкуем библиотеку с исполнимым файлом
target_link_libraries(MyProjectExe PRIVATE MyLibrary)
```

Здесь:

1. Мы создаём библиотеку `MyLibrary` из исходников `src/calculator.cpp`.

2. Мы создаём исполнимый файл `MyProjectExe` из `main.cpp`.

3. Мы связываем исполнимый файл с библиотекой `MyLibrary` через `target_link_libraries`.

---

## Почему CMake полезен?

CMake помогает организовать процесс сборки, позволяя:

- Легко переходить между различными платформами и компиляторами.

- Работать с большими проектами, где код разделён на несколько библиотек.

- Автоматически загружать и настраивать зависимости.

- Упрощать работу с IDE и тестами.

CMake служит связующим звеном, которое помогает управлять сборкой проекта, организуя всё в удобный и гибкий процесс.



---

## Google Test и CTest: Мини-конспект

### Что такое Google Test?

**Google Test** — это фреймворк для юнит-тестирования, разработанный Google. Он позволяет создавать, запускать и управлять тестами для C++-программ. Это одна из самых популярных библиотек для юнит-тестирования в C++.

#### Зачем нужен Google Test?

1. **Автоматизация тестирования**: Google Test позволяет писать и запускать тесты, автоматически проверяя работу функций или классов, и сообщая о том, что пошло не так.

2. **Поддержка множества полезных функций**: Google Test включает в себя множество полезных функций, таких как ассерты, мок-объекты, параметры тестов и прочее.

3. **Интеграция с CMake**: Google Test легко интегрируется с CMake, что позволяет автоматизировать тестирование в процессе сборки.

---

## Основы работы с Google Test

### 1. **Интеграция Google Test с CMake**

Для того чтобы начать использовать Google Test в проекте, его нужно подключить. Один из способов — использовать CMake для автоматической загрузки и настройки библиотеки с помощью **FetchContent**.

Пример конфигурации для CMake:

```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG v1.15.0
)
FetchContent_MakeAvailable(googletest)
```

- **`FetchContent_Declare`**: Эта команда загружает исходный код Google Test из репозитория на GitHub.

- **`FetchContent_MakeAvailable`**: Эта команда компилирует и делает доступным Google Test для использования в проекте.

---

### 2. **Простой тест с Google Test**

Чтобы написать тест, нужно включить Google Test в исходный код и определить тесты с помощью макроса `TEST`.

Пример простого теста:

```cpp
#include <gtest/gtest.h>

// Функция, которую будем тестировать
int add(int a, int b) {
    return a + b;
}

// Тестируем функцию add
TEST(AddTest, PositiveNumbers) {
    EXPECT_EQ(add(1, 2), 3);  // Проверка, что 1 + 2 == 3
}

TEST(AddTest, NegativeNumbers) {
    EXPECT_EQ(add(-1, -2), -3);  // Проверка, что -1 + -2 == -3
}

TEST(AddTest, Zero) {
    EXPECT_EQ(add(0, 0), 0);  // Проверка, что 0 + 0 == 0
}
```

Здесь:

- **`TEST(<имя_теста>, <имя_проверки>)`** — макрос для создания тестов. Первый параметр — это имя теста (например, `AddTest`), второй — имя конкретной проверки (например, `PositiveNumbers`).

- **`EXPECT_EQ(<выражение>, <ожидаемое_значение>)`** — это ассерты, которые проверяют, что результат выполнения функции совпадает с ожидаемым значением.

### 3. **Запуск тестов с помощью Google Test**

Для того чтобы запустить тесты, нужно собрать проект с Google Test и запустить полученный исполнимый файл, который автоматически выполнит все тесты.

Если ты интегрировал Google Test с CMake, то можешь добавить тесты в проект с помощью команды `add_test`:

```cmake
add_executable(MyTests test/my_tests.cpp)
target_link_libraries(MyTests gtest_main)

enable_testing()
add_test(NAME MyTests COMMAND MyTests)
```

Здесь:

- **`add_executable`** — создаём исполнимый файл для тестов.

- **`target_link_libraries`** — линковка с библиотекой Google Test.

- **`add_test`** — добавляем тесты в CMake-проект.

---

## Что такое CTest?

**CTest** — это инструмент для управления тестами, который является частью CMake. Он позволяет:

1. Запускать тесты, определённые в CMake проекте.

2. Собрать результаты тестов и выводить их в удобном формате.

3. Интегрировать тестирование с другими инструментами (например, с системой CI/CD).

### Зачем нужен CTest?

1. **Интеграция с CMake**: CTest тесно интегрирован с CMake и позволяет запускать тесты, которые определяются с помощью `add_test`.

2. **Автоматизация**: CTest автоматически выполняет все тесты, предоставляя удобный интерфейс для просмотра результатов.

3. **Поддержка CI/CD**: CTest хорошо интегрируется с системами непрерывной интеграции (CI/CD), позволяя автоматически запускать тесты на каждом этапе сборки.

---

## Основные команды CTest

### 1. **`enable_testing()`**

```cmake
enable_testing()
```

Эта команда включает поддержку тестирования в проекте. Она должна быть вызвана один раз в корневом `CMakeLists.txt`.

- **Зачем это нужно**: Без этой команды CTest не будет работать. Это обязательная команда, чтобы начать работать с тестами.

---

### 2. **`add_test(<имя_теста> <команда>)`**

```cmake
add_test(NAME MyTest COMMAND MyTestExe)
```

Эта команда добавляет тест в список тестов, которые могут быть выполнены с помощью CTest. Она указывает, какой исполнимый файл или команду следует запустить для выполнения теста.

- **Зачем это нужно**: С помощью этой команды CTest будет знать, какие тесты нужно выполнить.

---

### 3. **Запуск тестов с помощью CTest**

После того как тесты добавлены в проект, их можно запускать с помощью команды:

```bash
ctest
```

- **Зачем это нужно**: Эта команда запускает все добавленные тесты. CTest выполнит все тесты и отобразит результаты.

Для запуска только определённых тестов можно использовать:

```bash
ctest -R <имя_теста>
```

- **Зачем это нужно**: Если ты хочешь запустить только конкретный тест или группу тестов, можно использовать регулярные выражения, чтобы выбрать нужные тесты.

---

## Пример интеграции Google Test с CMake и CTest

Предположим, у нас есть проект с тестами, и мы хотим интегрировать его с CMake и CTest.

Структура проекта:

```
MyProject/
├── CMakeLists.txt
├── src/
│   └── calculator.cpp
├── test/
│   └── test_calculator.cpp
└── main.cpp
```

**CMakeLists.txt**:

```cmake
cmake_minimum_required(VERSION 3.10)

# Устанавливаем проект
project(MyProject)

# Настройка Google Test
include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG v1.15.0
)
FetchContent_MakeAvailable(googletest)

# Добавление библиотеки
add_library(calculator src/calculator.cpp)

# Добавление исполнимого файла для тестов
add_executable(MyTests test/test_calculator.cpp)
target_link_libraries(MyTests gtest_main calculator)

# Включаем поддержку тестирования
enable_testing()

# Добавляем тесты в CTest
add_test(NAME MyTests COMMAND MyTests)
```

**test/test_calculator.cpp**:

```cpp
#include <gtest/gtest.h>
#include "calculator.cpp"

// Пример теста
TEST(CalculatorTest, AddTest) {
    EXPECT_EQ(add(1, 2), 3);
}

TEST(CalculatorTest, SubtractTest) {
    EXPECT_EQ(subtract(5, 3), 2);
}
```

Здесь:

1. Мы подключаем Google Test через `FetchContent`.

2. Мы создаём исполнимый файл `MyTests`, который содержит наши тесты.

3. Мы добавляем тесты с помощью `add_test`.

4. Мы запускаем тесты с помощью команды `ctest`.

---

## Заключение

**Google Test** и **CTest** — это мощные инструменты для тестирования C++-кода:

- **Google Test** предоставляет удобный способ написания тестов с проверкой различных условий с помощью ассертов.

- **CTest** помогает интегрировать и автоматизировать процесс тестирования в рамках сборки с помощью CMake.

С помощью этих инструментов можно легко настраивать юнит-тестирование и интеграцию с CI/CD-системами, обеспечивая стабильность и качество кода.
