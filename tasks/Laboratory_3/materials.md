# Что сделать нужно

Необходимо для начала написать абстрактный класс Figure, который потом будем использовать для создания массива фигур.

После этого надо как раз таки написать массив фигур

Как задать прямоугольник по точкам?

Через 2 точки противоположных углов)

```
A-------B
|       |
|       |
|       |
C-------D
```

<svg width="250" height="150" xmlns="http://www.w3.org/2000/svg">
  <rect x="20" y="20" width="200" height="100" stroke="purple" fill="transparent" stroke-width="3"/>
  <text x="15" y="15" font-family="Arial" font-size="20" fill="skyblue">A</text>
  <text x="220" y="15" font-family="Arial" font-size="20" text-anchor="end" fill="lightgreen">B</text>
  <text x="15" y="140" font-family="Arial" font-size="20" fill="lightpink">C</text>
  <text x="220" y="140" font-family="Arial" font-size="20" text-anchor="end" fill="lightblue">D</text>
</svg>

Нам нужны лишь точки A и D

# Inline

`inline` в C++ — это ключевое слово, используемое как подсказка компилятору для замены вызова функции её телом непосредственно в точке вызова, что может улучшить производительность за счёт устранения накладных расходов на вызов функции. `inline` может применяться к функциям и переменным, при этом `inline` переменные позволяют обойти правило одного определения (ODR), позволяя иметь одно определение переменной в нескольких файлах. 

Применение к функциям

- **Принцип работы**: Компилятор может заменить вызов функции на её код, избегая затрат времени и ресурсов, связанных с переходом к другой части кода.
- **Оптимизация**: Устраняет издержки, такие как помещение аргументов в стек и переход к коду функции, что делает её выполнение быстрее.
- **Компромисс**: Может увеличить размер исполняемого кода из-за повторения кода функции в разных местах, что потенциально замедлит компиляцию.
- **Решение компилятора**: Компилятор сам решает, встраивать функцию или нет, даже если вы используете `inline`. Он может проигнорировать подсказку, если функция слишком большая, если её адрес передается как аргумент, или по другим причинам оптимизации.
- **Неявное встраивание**: Функция, определенная прямо в тексте объявления класса, неявно является `inline`-функцией. 

Применение к переменным

- **`inline` переменные (C++17)**: Позволяют определить переменную в нескольких местах без нарушения правила одного определения.
- **Свойства**: Все определения `inline` переменной должны быть идентичны. Определение переменной должно быть доступно в любом файле, который ее использует.
- **Типичные случаи использования**: Идеально подходят для глобальных констант, которые нужны в разных файлах, и для избежания проблем с ODR.

# string_view

`std::string_view` в C++ представляет собой немодифицируемый взгляд на существующую строку, не копируя её данные. Это позволяет эффективно работать с подстроками и различными типами строк (например, `std::string` и C-строками), избежать ненужного копирования данных и улучшить производительность, особенно в функциях, которые только читают строковые данные. 

Ключевые особенности и назначение:

- **Без копирования:** 
  
  `string_view` хранит только указатель на начало строки и её длину, а не саму строку. Это означает, что при передаче `string_view` в функцию, данные не копируются, что экономит ресурсы. 

- **Безопасность:** 
  
  Важно, чтобы строка, на которую ссылается `string_view`, существовала на протяжении всего времени жизни `string_view`. `string_view` не управляет временем жизни исходной строки. 

- **Универсальность:** 
  
  Благодаря неявному преобразованию, `string_view` может быть создан из `std::string`, `const char*` (C-строки) и других строковых типов, что делает функции, принимающие `string_view`, более универсальными. 

- **Непостоянство:** 
  
  `string_view` сам по себе не может изменять исходные данные. Однако, он имеет функции, такие как `remove_prefix()` и `remove_suffix()`, которые позволяют изменять представление, сужая видимую область строки, но не саму строку. 

- **Производительность:** 
  
  Поскольку `string_view` не требует копирования, его использование в качестве параметра функций для чтения строковых данных более эффективно, чем передача `std::string` по значению. 

Пример использования:

C++

```cpp
#include <iostream>
#include <string>
#include <string_view>

void print_message(std::string_view sv) {
    std::cout << sv << std::endl;
}

int main() {
    std::string s = "Hello, world!";
    const char* c_str = "This is a C-string.";

    print_message(s); // Передача std::string
    print_message(c_str); // Передача const char*
    print_message(s.substr(7)); // Передача подстроки

    return 0;
}
```







`assert` в C++ — это макрос для проверки условий, которые должны быть истинными во время выполнения программы. Если условие истинно, ничего не происходит. Если условие ложно, `assert` выводит сообщение об ошибке и прерывает выполнение программы, завершая её работу. 

Как это работает

- **Синтаксис**: `assert(условие)`.
- **Истинное условие**: Если выражение в скобках истинно (не равно нулю), программа продолжает работу без каких-либо действий.
- **Ложное условие**: Если выражение ложно (равно нулю), `assert` вызывает функцию `abort()`, завершая программу.
- **Сообщение об ошибке**: Выводятся имя файла, номер строки и само выражение, которое оказалось ложным.
- **Назначение**: `assert` используется для выявления логических ошибок во время разработки. Это не способ обработки ошибок, а инструмент для отладки, который можно отключить в релизной сборке. 

Когда использовать

- Для проверки условий, которые, по вашим расчётам, никогда не должны быть ложными.
- Для выявления логических ошибок в коде, например, проверки корректности результатов операций.
- Для тестирования ошибочных ситуаций, которые должны быть обработаны, но которые вы хотите проверить на этапе отладки. 

Отключение `assert`

- Если определить макрос `NDEBUG` перед включением `<cassert>`, все вызовы `assert` будут проигнорированы. Это стандартный способ отключить проверки в релизной версии программы.



# Deep copy — что делает и зачем нужен

- Deep copy (глубокое копирование) создаёт независимую копию всех владемых ресурсов объекта, т.е. не только копирует указатели, но и выделяет новые объекты по этим указателям (обычно через виртуальный метод clone()).
- Зачем: если класс владеет сырными указателями (как ваш ArrayOfFigures — хранит Figure* и в деструкторе удаляет их), то простое копирование указателей (shallow copy) приведёт к
  - двум объектам, указывающим на одни и те же Figure;
  - двойному удалению при разрушении (double delete) и неопределённому поведению.
- Решение: при копировании контейнера нужно вызывать clone() у каждой фигуры и сохранять указатель на новый независимый объект.

Пример deep copy (copy ctor):

```cpp
// ...existing code...
ArrayOfFigures::ArrayOfFigures(const ArrayOfFigures& other) {
    size = other.size;
    capacity = other.capacity;
    figures = new Figure*[capacity];
    std::fill_n(figures, capacity, nullptr);
    for (size_t i = 0; i < size; ++i) {
        figures[i] = other.figures[i] ? other.figures[i]->clone() : nullptr;
    }
}
```

Свап — зачем и как используется

- swap (обмен ресурсов) меняет внутреннее состояние двух объектов за O(1) (обмен указателей/целых значений). Полезен для:
  - реализации оператора присваивания по идиоме copy-and-swap (простота, безопасность при исключениях, корректная семантика).
  - эффективного перемещения ресурсов (move) — swap быстро меняет указатели вместо поэлементной копии.
- Идиома copy-and-swap: создать временную копию (которая может бросить), затем безопасно обменять состояния. После swap временная разрушается и освободит старые ресурсы.

Пример swap + copy-and-swap operator=:

```cpp
// ...existing code...
void ArrayOfFigures::swap(ArrayOfFigures& other) noexcept {
    using std::swap;
    swap(figures, other.figures);
    swap(size, other.size);
    swap(capacity, other.capacity);
}

ArrayOfFigures& ArrayOfFigures::operator=(const ArrayOfFigures& other) {
    if (this == &other) return *this;
    ArrayOfFigures tmp(other); // глубоко копирует
    swap(tmp);                 // теперь *this владеет новыми ресурсами
    return *this;              // tmp разрушается и освобождает старые ресурсы
}
```







`assert` в C++ может принимать сообщение для вывода об ошибке, хотя и не напрямую. Макрос `assert()` выводит сообщение, включающее ложное выражение, имя файла и номер строки, если условие ложно. Для включения дополнительной информации можно использовать строку, которая является частью проверяемого выражения, чтобы вывести её в сообщении об ошибке, если оно ложно, как показано в примере `assert(found && "Animal could not be found in database");`. 

Как это работает

- **Основная функция:** `assert(expression)` проверяет, истинно ли `expression`. Если `expression` ложно (равно `0`), программа завершает работу и выводит сообщение об ошибке.
- **Сообщение по умолчанию:** Сообщение об ошибке обычно содержит само выражение, имя файла и номер строки, где произошла ошибка.
- **Добавление пользовательского сообщения:** Чтобы добавить свое сообщение, используйте логическое И (`&&`), чтобы соединить ваше условие с строкой, как в примере: `assert(found && "Сообщение об ошибке");`.
- **Логика работы с сообщением:** Если `found` ложно, то `false && "Сообщение об ошибке"` будет ложно, и сообщение будет выведено. Если `found` истинно, то `true && "Сообщение об ошибке"` будет истинно, и `assert` не будет прерываться.





# std::transform

`std::transform` — это мощный алгоритм из Стандартной библиотеки шаблонов C++ (STL), определенный в заголовке `<algorithm>`. Он применяет функцию преобразования к элементам в одном или двух входных диапазонах и сохраняет результаты в выходном диапазоне. Представьте это как инструмент для отображения или объединения элементов в контейнерах, таких как векторы, массивы или списки.

## Синтаксис

Есть две основные формы:

1. **Унарная операция**: Применяет функцию к каждому элементу одного диапазона.
   
   ```cpp
   std::transform(InputIt first, InputIt last, OutputIt d_first, UnaryOp op);
   ```
   
   - `first`, `last`: Определяют входной диапазон.
   - `d_first`: Начало целевого диапазона.
   - `op`: Унарная функция (например, лямбда или функциональный объект).

2. **Бинарная операция**: Применяет функцию к парам из двух диапазонов.
   
   ```cpp
   std::transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOp op);
   ```
   
   - Принимает `first1`, `last1` для первого диапазона и `first2` для второго, вместе с выходным итератором и бинарной операцией.

## Типичные примеры использования

### Унарный пример:

Удвоение элементов в векторе:

```cpp
std::vector<int> input = {1, 2, 3, 4, 5};
std::vector<int> output(input.size());
std::transform(input.begin(), input.end(), output.begin(), [](int x){ return x * 2; });
// output: {2, 4, 6, 8, 10}
```

Вы также можете использовать указатели на функции или функторы в качестве функции преобразования[[1]](https://runebook.dev/en/articles/cpp/algorithm/transform).

### Преобразование на месте:

Преобразование всех букв в строке в нижний регистр:

```cpp
std::string s = "HELLO";
std::transform(s.begin(), s.end(), s.begin(), [](char c){ return std::tolower(c); });
// s: "hello"
```

### Бинарный пример:

Сложение элементов двух векторов:

```cpp
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = {4, 5, 6};
std::vector<int> result(3);
std::transform(v1.begin(), v1.end(), v2.begin(), result.begin(), [](int a, int b){ return a + b; });
// result: {5, 7, 9}
```

Здесь бинарная операция сопоставляет каждый элемент `v1` и `v2` и сохраняет их сумму в `result`[[2]](https://www.geeksforgeeks.org/cpp/transform-c-stl-perform-operation-elements/)[[3]](https://cplusplus.com/reference/algorithm/transform/).

## Ключевые моменты

- Работает с любым контейнером, поддерживающим итераторы.
- Выходной диапазон должен быть достаточно большим для результатов.
- Позволяет модификацию на месте, если входной и выходной диапазоны перекрываются.
- Принимает лямбды, функторы или указатели на функции.
- Возвращает итератор, указывающий за последний записанный элемент[[4]](https://en.cppreference.com/w/cpp/algorithm/transform.html).

## Практические случаи использования

- Применение математических функций ко всем элементам (например, масштабирование, абсолютное значение).
- Обработка текста (например, преобразование регистра, посимвольные операции).
- Объединение элементов из нескольких контейнеров (например, поэлементное сложение).

Для получения более подробной информации см. официальные справки и руководства:

- [cppreference.com](https://en.cppreference.com/w/cpp/algorithm/transform.html)[[4]](https://en.cppreference.com/w/cpp/algorithm/transform.html)
- [GeeksforGeeks: transform() in C++ STL](https://www.geeksforgeeks.org/cpp/transform-c-stl-perform-operation-elements/)[[2]](https://www.geeksforgeeks.org/cpp/transform-c-stl-perform-operation-elements/)
- [Cplusplus.com](https://cplusplus.com/reference/algorithm/transform/)[[3]](https://cplusplus.com/reference/algorithm/transform/)
- [Руководство Runebook.dev](https://runebook.dev/en/articles/cpp/algorithm/transform)[[1]](https://runebook.dev/en/articles/cpp/algorithm/transform)

---

1. [std::transform in C++: A Comprehensive Guide - Runebook.dev](https://runebook.dev/en/articles/cpp/algorithm/transform)
2. [transform () in C++ STL - GeeksforGeeks](https://www.geeksforgeeks.org/cpp/transform-c-stl-perform-operation-elements/)
3. [std:: transform - C++ Users](https://cplusplus.com/reference/algorithm/transform/)
4. [std::transform - cppreference.com](https://en.cppreference.com/w/cpp/algorithm/transform.html)





# std::swap

Алгоритм `std::swap` в C++ — это простая и широко используемая служебная функция для обмена значениями двух переменных. Он является частью Стандартной библиотеки шаблонов (STL) и работает с примитивными типами, контейнерами STL, массивами и пользовательскими объектами, если они поддерживают обмен.

**Определение и использование:**

- Основная цель `std::swap` — поменять местами содержимое двух своих аргументов.
- Оба аргумента должны иметь одинаковый тип.
- Синтаксис: `std::swap(a, b);`
- Начиная с C++11, он определен в заголовке `<utility>`, а в более старых версиях (до C++11) он находился в `<algorithm>`[[1]](https://en.cppreference.com/w/cpp/algorithm/swap.html)[[2]](https://www.geeksforgeeks.org/cpp/swap-in-cpp/).

**Детали реализации:**

- В классическом C++03 `swap` был реализован простым копированием:
  
  ```cpp
  template <typename T>
  void swap(T& a, T& b) {
      T tmp = a;
      a = b;
      b = tmp;
  }
  ```

- Начиная с C++11, для повышения эффективности, особенно для типов, которые дорого копировать, используются move-семантики:
  
  ```cpp
  template <typename T>
  void swap(T& a, T& b) {
      T tmp = std::move(a);
      a = std::move(b);
      b = std::move(tmp);
  }
  ```
  
  Это означает, что для контейнеров, таких как `std::vector`, эффективно обмениваются указатели на данные, а не фактическое содержимое, что делает операцию намного быстрее[[3]](https://stackoverflow.com/questions/25286544/how-does-the-standard-library-implement-stdswap)[[4]](https://optionalcpp.com/2023/02/12/swap.html).

**Примеры использования:**

- Обмен примитивных типов
  
  ```cpp
  int a = 1, b = 2;
  std::swap(a, b); // a = 2, b = 1
  ```

- Обмен контейнеров
  
  ```cpp
  std::vector<int> v1 = {1,2,3}, v2 = {4,5,6};
  std::swap(v1, v2); // v1 = {4,5,6}, v2 = {1,2,3}
  ```

- Для обмена массивов требуются массивы одного размера и типа, и элементы обмениваются индивидуально.

- Для пользовательских типов можно предоставить специализированную функцию обмена для эффективности, особенно если ваш тип управляет большими ресурсами, которую можно найти с помощью Argument-Dependent Lookup (ADL), если она размещена в том же пространстве имен[[2]](https://www.geeksforgeeks.org/cpp/swap-in-cpp/)[[3]](https://stackoverflow.com/questions/25286544/how-does-the-standard-library-implement-stdswap).

**Роль в алгоритмах STL:** `std::swap` широко используется в алгоритмах сортировки и перестановки (`std::sort`, `std::random_shuffle` и т. д.), поскольку обмен элементами является фундаментальной операцией для эффективной перестановки данных[[4]](https://optionalcpp.com/2023/02/12/swap.html).

**Плюсы и минусы:**

- **Плюсы:** Простой API, поддерживает большинство типов, эффективен для контейнеров STL, move-семантика (C++11+) делает его быстрее для сложных типов.
- **Минусы:** Пользовательские типы могут потребовать специализированный swap для максимальной эффективности; обмен массивов включает в себя поэлементный обмен, а не обмен указателями, что может быть медленнее.

**Ссылки и дополнительная литература:**

- [cppreference.com: std::swap](https://en.cppreference.com/w/cpp/algorithm/swap)[[1]](https://en.cppreference.com/w/cpp/algorithm/swap.html)
- [GeeksforGeeks: swap in C++](https://www.geeksforgeeks.org/cpp/swap-in-cpp/)[[2]](https://www.geeksforgeeks.org/cpp/swap-in-cpp/)
- [optionalcpp.com: More effcient algorithms with swap](https://optionalcpp.com/2023/02/12/swap.html)[[4]](https://optionalcpp.com/2023/02/12/swap.html)
- [W3Schools: C++ Algorithm swap function](https://www.w3schools.com/cpp/ref_algorithm_swap.asp)[[5]](https://www.w3schools.com/cpp/ref_algorithm_swap.asp)
- [StackOverflow: std::swap implementation and advice](https://stackoverflow.com/questions/25286544/how-does-the-standard-library-implement-stdswap)[[3]](https://stackoverflow.com/questions/25286544/how-does-the-standard-library-implement-stdswap)


